''' This script controls the hardware for the Bacterial Colony Screening Apparatus. It controls the camera and illumination system and via the microManager software package (www.micro-manager.org), and processes the results with Numpy and generates plots with Matplotlib. It is run via iPython, as this is our preferred scripting environment.The hardware used in the setup was a CoolSNAP ES2 CCD camera (Photometrics). The excitation and emission filter wheels and shutters were controlled by a Lambda 10-2 optical filter changer (Sutter Instrument), and the illumination system was a Lambda LS/30 Stand-Alone Xenon Arc Lamp (Sutter Instruments).Copyright (C) 2014 David Ngng (at) neuro (dot) mpg (dot) dePermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'''''' Initalization CodeblockThis section of code imports the needed modules, defines constants, and sets up the camera, shutter and filter system.'''import PILimport timeimport sysimport scipy.ndimageimport numpyimport MMCorePy # Note: add the installation directory of uManager to the system path, so that Python can access the needed files.import tkMessageBoximport tkFileDialogimport tkSimpleDialogimport Tkinter as tkimport matplotlib.pyplot as plt# Selection of fluorophores used for this experiment. Change as required.donor = 'Cerulean'acceptor = 'mCitrine'# Shutterwheel postions dictionary. This is a list of the various filters we have installed at each postion. The bandpass filters are described by the spectra of the fluorescent protein they are most often used with. The donor and acceptor variables are taken from the dictionary, using the keys selected above.ShutterWheel = {'Closed': 0, 'DsRed': 1, 'mOrange': 2, 'mCitrine': 3, 'eGFP': 4, 'Cerulean': 5, 'tSapphire': 6}donorEx = ShutterWheel[donor]donorEm = ShutterWheel[donor]acceptorEx = ShutterWheel[acceptor]acceptorEm = ShutterWheel[acceptor]# Imports the modules for the filterwheel, camera and shutterscore = MMCorePy.CMMCore();core.unloadAllDevices(); # makes sure there isn't anything previously loaded# Loads Cameracore.loadDevice("Camera", "PrincetonInstruments", "Camera-1");# Loads Serial interface the Sutter Controlboxcore.loadDevice("P1", "SerialManager", "COM1");core.setProperty("P1", "StopBits", "1");# setup filter wheelscore.loadDevice("Em", "SutterLambda", "Wheel-A");core.setProperty("Em", "Port", "P1");core.loadDevice("Ex", "SutterLambda", "Wheel-B");core.setProperty("Ex", "Port", "P1");core.loadDevice("SHUT", "SutterLambda", "Shutter-A 10-2");core.setProperty("SHUT", "Port", "P1");core.initializeAllDevices();# Sets the filters to closed, which is Position 0. Also sets the shutters wheel to fastest speedcore.setState("Ex", 0);core.setProperty("Ex", "Speed", 4);core.setState("Em", 0);core.setProperty("Em", "Speed", 4);# Final setup for cameracore.setCameraDevice("Camera");# This trick hides the empty TK window that is generated when TK is startedroot = tk.Tk()root.withdraw()def snapImage(ExPos, EmPos, Exposure):    """ This function takes a picture with a given excitation/emission filter and exposure time, and returns an image.    """    core.setAutoShutter(0)    core.setState("Ex", ExPos);    core.setState("Em", EmPos);    core.setExposure(Exposure)    core.setShutterOpen(1)    core.snapImage()    pic = core.getImage()    core.setShutterOpen(0)    core.setState("Ex", 0)    core.setState("Em", 0)    return picdef newMask():    """ This function generates a mask, that sets the area outside the plate to black. Its an array of zeros the size of the picture, with a filled circle of 1's in the location of the petri dish. This is done to make the colony-detection algorithm work more accurately.    """    # these are the parameters for the mask, i.e. its height and width, and radius and center of the circle as measured in pixels. The circle parameters are determined by measuring a picture taken of a plate.    h,w = 1040, 1392    a,b = 480, 720    r = 300    y,x = numpy.ogrid[-a:h-a, -b:w-b]	# Thanks, Mr. Pythagorus!    mask = x*x + y*y <= r*r    array = numpy.zeros((h, w))    array[mask] = 1    return arraydef segmentImage(picture):    """ This function takes a picture, and tries to isolate the colonies    """	# creates a new mask, from the function above    mask = newMask()	#uses the mask to get rid of the background    masked = mask*picture	# only takes pixels 3 times greater than the standard deviation of the pixel intensity. This has been found to reliably find only fluorecent colonies in our system.    binaryImage = numpy.where(masked>numpy.mean(picture)+2*numpy.std(picture),1,0)	# This function eroded the binary image, getting rid of tiny specs, and removing the edges of blobs.    binaryImage = scipy.ndimage.binary_erosion(binaryImage)	# This function fill in any gaps in blobs.    binaryImage = scipy.ndimage.binary_opening(binaryImage,structure=numpy.ones((2,2)))	# This function identifies the colonies, and gives them labels and a total.    labeled,nr_objects = scipy.ndimage.label(binaryImage)    return labeled,nr_objectsdef getRatiometric(ex1, em1, em2, colonies, exposure):    """ This is takes the location of previously found colonies, and the takes two images, one of the donor and one of FRET.    It then uses the generated images to get the ratiometric responce for all the colony, using the colony locations.	It returns an array, of Donor fluorence, FRET fluorescence, and FRET Ratios.      """    core.setAutoShutter(0)	# Gets Donor Imaging    core.setState("Ex", ex1);    core.setState("Em", em1);    core.setExposure(exposure)    core.snapImage()    donorIMG = core.getImage()	# Gets FRET Imaging    core.setState("Em", em2);    core.snapImage()    fretIMG = core.getImage()	# closes filter wheel    core.setState("Ex", 0)    core.setState("Em", 0)	# Calculates Donor,Acceptor and FRET values    donorValues = scipy.ndimage.mean(donorIMG, colonies[0], numpy.unique(colonies[0]))    fretValues = scipy.ndimage.mean(fretIMG, colonies[0], numpy.unique(colonies[0]))    ratioValues = fretValues/donorValues	# puts the values together in a 2D array    data_slice = numpy.vstack([donorValues, fretValues, ratioValues])    return data_slice''' Measurement CodeblockThis section of code allows the user to select the file location, records images and calculated FRET ratios, and prompts the user to spray the plates.'''# Gets the directory location for saving the filesdirectory = tkFileDialog.askdirectory()plate_name = tkSimpleDialog.askstring('File', 'Plate Name:')# Gets the date in the nice string format, to add to the graphs at the enddatestr = time.strftime("%d %b %Y %H:%M:%S", time.localtime())# Checks to see if the plate name is actually there, exit if nothing has been entered in the popup boxif len(plate_name) == 0:    sys.exit()if not directory:    sys.exit()# takes a picture, finds the coloniespicture = snapImage(acceptorEx,acceptorEm,1000)colonies = segmentImage(picture)# generates plots for the user to decide if they want to continue, e.g. have the correct filters and exposure time been chosen to generate good images? Have enough colonies been found? If not, exit gracefully.plt.figure(0, (6,10))plt.subplot(2,1,1)plt.imshow(picture[150:820,370:1060]*100, cmap = 'gray')plt.axis("off")plt.subplot(2,1,2)plt.imshow(colonies[0][150:820,370:1060], cmap = 'jet')plt.annotate("Colonies found: %d" %int(colonies[1]-1), xy = (50,50),bbox = dict(boxstyle = 'round,pad=0.2', fc = 'yellow'))plt.axis("off")plt.show()imageOK = tkMessageBox.askyesno('Option','Continue?') # Dialog box: Do you want to continue?print "here"print imageOKif not(imageOK):    sys.exit()# The user is satisfied, so go on to record the baseline ratiometric values and plot them in realtime. It records 5 data points for each colony, at 15 second intervalsplt.close()core.setShutterOpen(1)core.setAutoShutter(0)init = time.time()data = getRatiometric(donorEx, donorEm, acceptorEm, colonies, 100)[numpy.newaxis,...]t = time.time() - initplt.figure(1)plt.plot(data[:,2,:])plt.draw()plt.show()# Turns on real-time plotting in Matplotlibplt.ion()  if t <= 5:    delay = 5-t    time.sleep(delay)    print 'here'    print delayfor i in range(5):    init2 = time.time()    data = numpy.vstack([data, getRatiometric(donorEx, donorEm, acceptorEm, colonies, 100)[numpy.newaxis,...]])    plt.clf()    plt.plot(data[:,2,:])    plt.draw()    # This code account for the variable delay in recording an imaage.    t = time.time() - init2     if t <= 5.0:        delay = 5.0-t        time.sleep(delay)    print "Recording %d of 5" %(i+1)# Prompts the user to add Ionomycin, then records 25 data points for each colony, at 15 second intervals.tkMessageBox.showinfo("Command", "Add Ionomycin")print "continuing after ionomycin addition"init = time.time()t = time.time() - initfor i in range(25):    init2 = time.time()    data = numpy.vstack([data, getRatiometric(donorEx, donorEm, acceptorEm, colonies, 100)[numpy.newaxis,...]])    plt.clf()    plt.plot(data[:,2,:])    plt.draw()    # This code account for the variable delay in recording an imaage.    t = time.time() - init2    if t <= 5.0:        delay = 5.0-t        time.sleep(delay)    print "Recording %d of 25" %(i+1)# Prompts the user to add Calcium, then records 25 data points for each colony, at 15 second intervals.tkMessageBox.showinfo("Command", "Add Calcium")print "continuing after calcium addition"init = time.time()t = time.time() - initfor i in range(25):    init2 = time.time()    data = numpy.vstack([data, getRatiometric(donorEx, donorEm, acceptorEm, colonies, 100)[numpy.newaxis,...]])    plt.clf()    plt.plot(data[:,2,:])    plt.draw()    # This code account for the variable delay in recording an imaage.    t = time.time() - init2    if t <= 5.0:        delay = 5.0-t        time.sleep(delay)    print "Recording %d of 25" %(i+1)print "Finished aquisition"# last image updateplt.figure(0)plt.show()''' Analysis CodeblockThis section of code analyses the recorded data, and selects the best responding colonies. It generates plots, highlighting the best responders, and generates an image the shows the best responding colonies locations, to make picking easier.'''# Find staring and ending FRET ratios, from 10 reading just before calcium addition, to the last 10 readings. start = numpy.mean(data[20:30,2,:], axis = 0)end = numpy.mean(data[-10:,2,:], axis = 0)# Sort the selection to find those colonies with the greatest response, as defined by change-in-FRET-ratio divided by the starting FRET ratio raised to an arbitrary power. Raised to 1, the starting ratio is ignored, and at 2, has equal value to the ratio change.selection = (end-start)/(start ** 1.5)sel = numpy.argsort(selection)# Generate a picture of colonies with best locations markedplt.figure(figsize=(8, 8))plt.imshow(picture[150:820,370:1060], cmap = 'gist_yarg')xs = []ys = []for i in range(10):    xpos = scipy.ndimage.center_of_mass(picture, colonies[0], sel[-1-i])[0]-151    ypos = scipy.ndimage.center_of_mass(picture, colonies[0], sel[-1-i])[1]-370    xs.append(xpos)    ys.append(ypos)    plt.annotate(        i+1,        alpha=0.5,        color = 'b',        xy = (ypos,xpos), xytext = (-5, 5),        textcoords = 'offset points', ha = 'right', va = 'bottom',        arrowprops = dict(arrowstyle = '->', connectionstyle = 'arc3,rad=0'))c = plt.scatter(ys,xs, color = 'r')c.set_alpha(0.25)plt.axis("off")plt.title('Colony Selection from Plate: ' + plate_name + ', at ' + datestr)plt.savefig(directory + '/' + plate_name + '_Colonies', papertype='A4')plt.close()# Scatter plot of Calcium response, with the best ten colonies marked in redplt.figure(figsize=(9, 6))plt.scatter(start[sel[-10:]], (end[sel[-10:]]-start[sel[-10:]])/start[sel[-10:]], c = 'r')plt.scatter(start[sel[0:-10]], (end[sel[0:-10]]-start[sel[0:-10]])/start[sel[0:-10]], c = 'b')plt.title('Colony Selection from Plate: ' + plate_name + ', at ' + datestr)plt.xlabel(r'$\o Ca^{2+}\frac{Acceptor}{Donor}$')plt.ylabel(r'$\frac{(\o Ca^{2+}\frac{Acceptor}{Donor})-(+Ca^{2+}\frac{Acceptor}{Donor})}{\o Ca^{2+}\frac{Acceptor}{Donor}}$')for i in range(10):    plt.annotate(i+1, xy = (start[sel[-1-i]],(end[sel[-1-i]]-start[sel[-1-i]])/start[sel[-1-i]]), xytext = (-10, 10),        textcoords = 'offset points', ha = 'right', va = 'bottom',        bbox = dict(boxstyle = 'round,pad=0.2', fc = 'yellow', alpha = 0.5),        arrowprops = dict(arrowstyle = '->', connectionstyle = 'arc3,rad=0'))plt.savefig(directory + '/' + plate_name + '_Selection', papertype='A4')plt.close()# Traces of Calcium response for the best ten coloniesplt.figure()plt.plot(numpy.array([numpy.arange(0,numpy.shape(data)[0],1),]*7).T,data[:,2,sel[-1:-8:-1]] );plt.plot(numpy.array([numpy.arange(0,numpy.shape(data)[0],1),]*3).T,data[:,2,sel[-8:-11:-1]], linestyle='--' );plt.legend( ('1', '2', '3', '4', '5','6','7','8','9','10'))plt.title('Colony Traces from Plate: ' + plate_name + ', at ' + datestr)plt.xlabel(r'Time (second)')plt.ylabel(r'$\frac{YFP}{Donor}$')plt.show()plt.savefig(directory + '/' + plate_name + '_Traces', papertype='A4')# saves raw data and images, for further analysisnumpy.save(directory + '/' + plate_name, data)numpy.save(directory + '/' + plate_name + '_Image', picture)# Offer exit dialogimageOK = tkMessageBox.askyesno('Finished','Close?')if (imageOK):    sys.exit()